# 项目说明

本项目包含多个版本的核心代码，适配树莓派与 Windows 环境，用于图像检测与识别。以下为版本区别、环境适配、以及树莓派按键操作说明

---

## 1. 核心代码版本区别

| 代码版本                |    适用环境 | 核心特点                                                     |
| ------------------- | ------: | -------------------------------------------------------- |
| **final\_v2**       |     树莓派 | 基础版检测代码，曝光控制功能独立拆分                                       |
| **final\_v2\_auto** |     树莓派 | 进阶版：将 4 个独立检测模块的「曝光控制」集成至 `maincontrol` 主函数（见代码第 8–11 行） |
| **final\_video**    | Windows | 中后期方案验证版（功能未完善），**无** `detect_number_shapes` 核心功能        |
### 🎥 视频资料(bilibili)

- [电赛国一翻车最离谱的一集](https://www.bilibili.com/video/BV1yQeEzFE53/?vd_source=2b32370526feca214e420f71e8eaebf1)  
- [电赛C题 国一级软件方案-开源+代码详解-像素战争(上)](https://www.bilibili.com/video/BV1DphZzrEGn/?vd_source=2b32370526feca214e420f71e8eaebf1)  
- 电赛C题 国一级软件方案-开源+代码详解-像素战争(中) —— *敬请期待*  
- 电赛C题 国一级软件方案-开源+代码详解-像素战争(下) —— *敬请期待*  
---
# 👉 我的B站主页：[内卷不能](https://space.bilibili.com/457880155?spm_id_from=333.788)
---
## 2. 环境适配与使用注意事项

### 2.1 树莓派版本（`final_v2` / `final_v2_auto`）

* **依赖工具**
  最终拍摄图片需使用树莓派原生工具 **rpicam-still**（属于 `rpicam apps` 套件），**Windows 环境无法运行**。

* **图像预处理**
  树莓派搭载的长焦镜头 CMOS 为「竖直放置」，代码中已默认对图像进行 **顺时针旋转 90°** 处理，确保标靶在画面中竖直显示（长边为高度），保证识别长宽逻辑正确。

### 2.2 Windows 版本（`final_video`）

* **功能定位**
  仅用于「连续视频处理流程体验」，**不保证精度**，不建议作为正式测试使用。

* **硬件限制**
  默认调用笔记本 **前置广角摄像头**，存在画质差、畸变明显的问题，实测数据不准确属于正常现象。

* **关键 bug（长宽颠倒）**

  * **问题**：`final_video` 读取横屏视频流，与树莓派的竖屏预处理逻辑冲突，可能导致 **识别长宽颠倒**，从而出现数据严重偏小（误差 > 1 cm）。
  * **解决方案**：

    1. **物理调整**：将标靶横向放置并尽量填满广角摄像头的横屏画面；
    2. **代码调整**：在 `ppcm` 计算公式中交换 `rect_w`（宽）与 `rect_h`（高）的位置。

* **特殊模块说明**

  * `detect_turn`：不受长宽颠倒影响。
  * `multi_shapes` / `all_detect_easy`：基于同一核心逻辑，可能存在长宽颠倒问题，需按上述方案修复。

---

## 3. 新增与变更

* **新增：四个用户自定义的 BCM 引脚 → `detect_number_shapes_V11.py`**（详见下方按键映射与操作流程）
* `maincontrol.py` 通过 **BCM 编号** 的 GPIO 监听按键事件，触发对应脚本与参数。

> **重要提示：** 接线与编程均采用 **BCM 编号**（非 BOARD 物理引脚编号）。接线错误会导致按键无效或触发错误脚本。

---

## 4. 操作说明（树莓派）

树莓派端通过 `maincontrol.py` 监听 **BCM 编号** 的 GPIO 按键；按键分为三类：

* **模式键**：触发某一检测脚本（有的携带参数，表示“第 N 大”）。
* **数字输入区**：用于输入题面数字（用于“智能工人”欺骗输入逻辑）。
* **确认键**：提交并执行当前设置（模式 + 数字输入）。

### 4.1 按键映射（BCM 编号）

下面为 `BUTTON_MAP`（实际在 `maincontrol` 中使用的 BCM 映射）：

```python
BUTTON_MAP = {
    21: { 'path': './all_detect_easy_V3.py', 'arg': None },
    20: { 'path': './detect_multi_shapes_V12_pi.py', 'arg': None },   # 按键1

    16: { 'path': './detect_number_shapes_V11_pi.py', 'arg': 1 },     # 按键2 → 模式 1
    12: { 'path': './detect_number_shapes_V11_pi.py', 'arg': 2 },     # 按键3 → 模式 2
    26: { 'path': './detect_number_shapes_V11_pi.py', 'arg': 3 },     # 按键4 → 模式 3
    19: { 'path': './detect_number_shapes_V11_pi.py', 'arg': 4 },     # 按键5 → 模式 4
    13: { 'path': './detect_number_shapes_V11_pi.py', 'arg': 5 },     # 按键6 → 模式 5

    5:  { 'path': './detect_turn.py', 'arg': None },

    # 数字输入区（实际 BCM 编号）
    18: { 'type': 'number', 'value': 0 },  # 数字 0
    23: { 'type': 'number', 'value': 1 },  # 数字 1
    24: { 'type': 'number', 'value': 2 },  # 数字 2
    25: { 'type': 'number', 'value': 3 },  # 数字 3
    17: { 'type': 'number', 'value': 4 },  # 数字 4
    27: { 'type': 'number', 'value': 5 },  # 数字 5
    22: { 'type': 'number', 'value': 6 },  # 数字 6
    10: { 'type': 'number', 'value': 7 },  # 数字 7
    9:  { 'type': 'number', 'value': 8 },  # 数字 8
    11: { 'type': 'number', 'value': 9 },  # 数字 9
    8:  { 'type': 'confirm' }              # 确定键
}
```

---

### 4.2 `detect_number_shapes` 的特殊说明（“智能工人”方案）

**本方案并非通过训练 AI 模型实现目标识别，而是采用人为输入与程序规则来选择目标 —— 因为比赛时间短，本人精力有限 无法训练模型。**

* **编号含义（模式参数）**：表示要选择的“第 N 大”目标（例如 `arg=3` 表示选择第三大的目标）。该参数由 **模式键**（上表中带 `arg` 的条目）触发并传入脚本。
* **数字输入区的作用**：用于输入题面上的“编号”（即题目要求的编号），但在程序中仅作为“欺骗输入”展示，**不直接决定检测目标**。真正决定要输出的是模式键传入的 “第 N 大” 参数。
* **确认流程**：模式键 → 数字输入 → 确认（按 `BCM 8`），程序按模式参数选择检测结果并输出。

#### 操作示例（务必按顺序执行）

题面示例：**“检测 5 号，为第三大的正方形”**（即题目给出的编号为 5，但正确目标是“第三大的正方形”）：

1. **按模式键**：按下 **BCM 26**（该键在 `BUTTON_MAP` 中的 `arg` 为 `3`，表示“第 3 大”）。
2. **输入题面数字**：在“数字输入区”按下表示 `5` 的按键（`BCM 27`）。
3. **按确认键**：按下 **BCM 8**。

程序将按照模式参数（第 3 大）输出检测到的第三大的正方形 —— 即使你在数字区输入的是 5，输入数字只用于“欺骗”题面显示，**真正选择逻辑以模式参数为准**。

---

## 5. 其他模块（一览）

* `all_detect_easy_V3.py`：简单图形测量:正方形三角形圆形三合一,且可以测距,完美秒杀基础题。
* `detect_multi_shapes_V12_pi.py`：多图形检测,可以应对多分离图形或是融合(重叠)图形,精度很高,效果拔群。
* `detect_turn.py`：检测斜放置情景精度高,且对旋转的阈值无要求,远远超出比赛旋转范围。

---

## 6. 注意事项与小贴士

* **严格使用 BCM 编号接线**（不要混淆为 BOARD/物理引脚编号）。
* 若使用树莓派长焦镜头，请确认相机方向与代码中 **顺时针旋转 90°** 的预处理保持一致（见第 2.1 节）。
* Windows 版本仅用于流程体验，不建议做定量测试或比赛提交。
* 若出现数据偏小或长宽互换，优先检查：

  1. 镜头放置方向（竖/横）；
  2. `ppcm` 计算中 `rect_w` 与 `rect_h` 是否被错误使用或颠倒。
* 若需要，我可以帮你把本 README 加上 **快速上手（Quick Start）** 与 **接线示意图**（ASCII / Mermaid），或把按键映射画成流程图，直接嵌入 README。
